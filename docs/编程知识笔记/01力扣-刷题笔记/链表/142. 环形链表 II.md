
[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF

# 知识点


# 题目

给定一个链表的头节点  `head` ，**返回链表开始入环的第一个节点**。 _如果链表无环，则返回 `null`。_

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

**输入：**head = [3,2,0,-4], pos = 1
**输出：**返回索引为 1 的链表节点
**解释：**链表中有一个环，其尾部连接到第二个节点。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**输入：**head = [1,2], pos = 0
**输出：**返回索引为 0 的链表节点
**解释：**链表中有一个环，其尾部连接到第一个节点。

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**输入：**head = [1], pos = -1
**输出：**返回 null
**解释：**链表中没有环。

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

# 解题思路
需要用到**数学的思维**，求出距离的关系，才能设计出相遇的走法。

利用双指针，fast 和 slow 
快指针一次走两步，慢指针一次走一步。
因为链表的后方有一个环，所以两个指针注定会在**环内第一次相遇**。记录这个相遇节点有重要的数学意义。
相遇节点之前到。环形节点的距离用**y**表示。  剩下的距离到环形节点的用**z**表示。

在第一次相遇前，**fast**可能在环内。走了，**n圈**，n>=1。这个n 的值，由快慢指针的速度差和x的距离和环的大小所决定
因为**fast比slow指针**每次多走一步，所以我们可以知道快指针行走的距离是慢指针的两倍
得出公式：
**(x + y) * 2 = x + y + n (y + z)**
即 **x + y = n (y + z)**
即 **x = (n - 1) (y + z) + z**

这个公式有重要的意义。从现在开始，如果我们让两个指针重新出发。A指针从头节点出发，B指针从相遇节点的当前位置出发。  两个指针每次都**只移动一步**

所以我们可以知道**当a指针走完x距离时**就会走到**环形入口节点**。
而**B指针**，需要走z距离，加上n-1圈的环形。当时B 指针刚好在相遇节点的位置。距离到环形节点正好是**Z距离**。
所以我们知道指针跟a指针恰好会在环形相交点。相遇!!! 
完成

开始写代码

![[Pasted image 20240430140229.png]]


# 难度 中等


# 代码

## Java

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;

            if(fast == slow){
                slow = head;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;

                }return fast;
            }
        }return null;
    }
}
```

- 时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n
- 空间复杂度: O(1)

### [#](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E8%A1%A5%E5%85%85)

## python
```python


```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)

## 官方python

```python



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)



## 官方cpp

```c



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)


# 总结



# 相似题目

