题目链接-[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html
# 知识点
- 链表
- 递归

# 题目
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

**输入：**head = [1,2,3,4]
**输出：**[2,1,4,3]

**示例 2：**

**输入：**head = []
**输出：**[]

**示例 3：**

**输入：**head = [1]
**输出：**[1]

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

# 解题思路
用到递归的思维。总的来讲就是每两个节点相互交换，交换完之后再交换下两个节点。直到这两个节点中有一个是null 为止，然后停止交换，因为已经到头了。

先加入一个 dummy 节点。
cur 的指针位置，代表着这个指针后面的两个节点需要被交换。记作 1,2 节点。
因为我们要选择一个被交换的两个节点之外的指针，保证不被交换所影响。

初始化
ListNode cur = dummy;
        ListNode temp ;
        ListNode firstHead;
        ListNode secondHead;
        
先依次保存好这四个个节点的初始位置，
步骤一，先将cur指针指向第二个节点。即为新第一节点
步骤二，再将当前新的第一节点指向 旧的第一节点。即为新第二节点
步骤三，将新第二节点指向旧的第三节点。
此时交换完成
将当前当前指针指向新的第二节点。保存为当前位置，为下一轮交换做定位。即下一轮交换，交换新的cur指针的后面两个节点，即为 新的1,2节点。进入递归。

操作步骤
![[Pasted image 20240429010039.png]]
操作完成之后
![[Pasted image 20240429010108.png]]
# 难度 中等


# 解法代码

## Java
```Java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        
        ListNode cur = dummy;
        ListNode temp ;
        ListNode firstHead;
        ListNode secondHead;
        while(cur.next != null && cur.next.next != null){
            temp = cur.next.next.next;

            secondHead = cur.next.next;
            firstHead = cur.next;
            cur.next = secondHead;
            secondHead.next = firstHead;
            firstHead.next = temp;
            cur = firstHead;
        }
        return dummy.next;

    }
}
```


```java
class Solution {
  public ListNode swapPairs(ListNode head) {
        ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点
        dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode cur = dumyhead;
        ListNode temp; // 临时节点，保存两个节点后面的节点
        ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点
        ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点
        while (cur.next != null && cur.next.next != null) {
            temp = cur.next.next.next;
            firstnode = cur.next;
            secondnode = cur.next.next;
            cur.next = secondnode;       // 步骤一
            secondnode.next = firstnode; // 步骤二
            firstnode.next = temp;      // 步骤三
            cur = firstnode; // cur移动，准备下一轮交换
        }
        return dumyhead.next;  
    }
}
```


```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```
## python
```python


```

## 官方python

```python



```



## 官方cpp

```c



```

# 复杂度解析



# 相似题目

