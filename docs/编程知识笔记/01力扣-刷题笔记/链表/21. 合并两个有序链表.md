
[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

# 知识点
- 链表
- 递归
- 链表排序

# 题目
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

**输入：**l1 = [1,2,4], l2 = [1,3,4]
**输出：**[1,1,2,3,4,4]

**示例 2：**

**输入：**l1 = [], l2 = []
**输出：**[]

**示例 3：**

**输入：**l1 = [], l2 = [0]
**输出：**[0]

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

# 解题思路
先创建一个 dummy 节点，作为一个新的链表

ListNode dummy = new ListNode (-1);

用 while 递归，当 L1 或 L2 为 null 时候，才停止。

设置一个指针 cur = dummy；
这里有两个判断。 当 L1.val>=L2.val 时， 
	cur = L2 ， 
	移动当前L1指针到下一个节点
else L1.val< L2.val 时
	cur = L1;
	移动当前l二节点到下一个节点。 L2 = L2.next
昨晚合并节点后，cur 要往前一一个， cur = cur.next;

 当一个短的链表遍历完之后会跳出外循环，这时候要将短的链表接到长链表，剩下的节点
 做一个判断 
 if L1 == null 
	 cur.next = L2
if L2 == null
	cur.next = L1;

最后返回 dummy.head 。 return 


# 代码

## Java

```Java

class Solution {
    public ListNode mergeTwoLists(ListNode L1  , ListNode L2) {
        ListNode dummy = new ListNode(-1);

        ListNode cur = dummy;
        while(L1!=null && L2!=null){
            if(L1.val<=L2.val){
                cur.next = L1;
                L1 = L1.next;
            }else{
                cur.next = L2;
                L2 = L2.next;
            }
            cur = cur.next;
        }
        if(L1==null){
            cur.next = L2;
        }else {
            cur.next = L1;
        }
        return dummy.next;
    }   
```


```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值
        ListNode dummy = new ListNode(-1);

        // 设置一个指针，指向虚拟节点
        ListNode pre = dummy;

        // 通过一个循环，不断的比较 l1 和 l2 中当前节点值的大小，直到 l1 或者 l2 遍历完毕为止
        while (l1 != null && l2 != null) {
            // 如果 l1 当前节点的值小于等于了 l2 当前节点的值
            if (l1.val <= l2.val) {
                // 让 pre 指向节点的 next 指针指向这个更小值的节点
                // 即指向 l1
                pre.next = l1;
                // 让 l1 向后移动
                l1 = l1.next;
            }else {
                // 让 pre 指向节点的 next 指针指向这个更小值的节点
                // 即指向 l2
                pre.next =l2;
                // 让 l2 向后移动
                l2 = l2.next;
            }
            // 让 pre 向后移动
            pre = pre.next;
        }

        // 跳出循环后，l1 或者 l2 中可能有剩余的节点没有被观察过
        // 直接把剩下的节点加入到 pre 的 next 指针位置
        
        // 如果 l1 中还有节点
        if (l1 != null) {
            // 把 l1 中剩下的节点全部加入到 pre 的 next 指针位置
            pre.next = l1;
        }

        // 如果 l2 中还有节点
        if (l2 != null) {
            // 把 l2 中剩下的节点全部加入到 pre 的 next 指针位置
            pre.next = l2;
        }

        // 最后返回虚拟节点的 next 指针
        return dummy.next;
    }
}

```
- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1)O(1)。只需要常数的空间存放若干变量。

## python
```python


```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)

## 官方python

```python



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)



## 官方cpp

```c



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)


# 总结



# 相似题目

