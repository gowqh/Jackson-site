
[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF

# 知识点
- 递归
- 链表
- 两两交换的思路，进行递归

# 题目
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

**输入：**head = [1,2,3,4,5]
**输出：**[5,4,3,2,1]

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

**输入：**head = [1,2]
**输出：**[2,1]

**示例 3：**

**输入：**head = []
**输出：**[]

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

# 解题思路
将每个链表的指向反转，
head节点 指向 null， 原先第二个节点指向第一节点

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:
![[Pasted image 20240429221750.png]]


需要使用 双指针， 实际三指针。
left  ， right  ， temp
temp 保存 right.next; 的位置

建立一个 dummy 节点，
初始化

right = 第一号节点位置
left = null 节点位置

开始进入递归的链表反转，  
while right != null 时，才运行。 即把所有的元素遍历一遍。
初始化，保存一个有用的节点，temp = right.next;
将 right.next = left；
移动两个指针
	left = right；
	right = temp；  然后开始递归

return left;  以为 right 指针已经指向 null；


# 难度 简单


# 代码

## Java

```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode left = null;
        ListNode right = head;
        
        while (right != null){
            ListNode temp = right.next; // 储存一个临时的节点，为右指针的下一个节点。
            right.next = left; // 将链表反转，右边的指向左边
            left = right; // 移动指针，先将左指针右移一个
            right = temp ; // 再将 右指针右移一个
        }
        return left;
        
    }
}
```

- 时间复杂度: O(n) 
- 空间复杂度: O(1)

## python
```python


```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)

## 官方python

```python



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)



## 官方cpp

```c



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)


# 总结



# 相似题目

[反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

[回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
