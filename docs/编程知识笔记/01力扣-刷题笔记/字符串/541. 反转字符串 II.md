
[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

# 知识点

- 双指针
- 字符翻转

# 题目
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

**输入：**s = "abcdefg", k = 2
**输出：**"bacdfeg"

**示例 2：**

**输入：**s = "abcd", k = 2
**输出：**"bacd"

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文组成
- `1 <= k <= 104`

# 解题思路
先将 string 转化为 chart 单个的字符。

让 i 的指针从 0 开始，每次都走 2k 的长度。这样就能走出一整个判断的区间。
然后设置两个指针，left  和 right 指针
left 的起始位置是 i 的位置， right 的起始位置是 i+k 的位置
两个指针相互靠拢，做字符串反转的操作

这时我们要判断 right 的位置是否为一个完整的 k 长度， 所以要判断当前 chr.length 是否 大于 left+k。 取这两个数中的 较小的数。
	int end = Math.min(ch.length - 1, start + k - 1);

然后就对 left 和 right 的 位置做翻转操作， 使用 while ， 当 left < right 时才能停止。  并且每步操作，left++，right--;






# 难度 中等


# 代码

## 代码难点

将一个长字符串，分割成单个字符的列表
```java
char[] chart = s.toCharArray();

```
## Java

```Java
class Solution {
    public String reverseStr(String s, int k) {
        char[] chart = s.toCharArray();
        
        
        for (int i=0 ; i<chart.length ; i += 2*k){
            int left = i;
            int right = i+k-1;
            right = Math.min(chart.length-1 , i+k-1);
            
            while (left < right){
                char tem = chart[left];
                chart[left] = chart[right];
                chart[right] = tem;

                left +=1;
                right -=1;
            }
        }
        return new String(chart) ;
    }
}
```

- 时间复杂度: O(n) 
- 空间复杂度: O(1)

## python
```python


```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)

## 官方python

```python



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)



## 官方cpp

```c



```
- 时间复杂度: O(n) 
- 空间复杂度: O(n)


# 总结



# 相似题目

